---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by blu.
--- DateTime: 18.01.23 16:56
---
---
class = require('middleclass')

-- Utility
do
  unpack   = unpack or table.unpack

  val      = {
    -- type checks
    ofTypes     = function(ts, v)
      assert(type(ts)=='table' and val.allOfType('string', ts),
             '`val.ofTypes` arg#1: table of strings expected')
      for _, t in ipairs(ts) do if type(v)==t then return true end end
      return false
    end,
    allOfType   = function(t, vs)
      assert(type(t)=='string', '`val.allOfType` arg#1: string expected')
      assert(type(vs)=='table', '`val.allOfType` arg#2: table expected')
      if #vs==0 then return false end
      for _, v in ipairs(vs) do if type(v)~=t then return false end end
      return true
    end,
    allOfTypes  = function(ts, vs)
      assert(type(ts)=='table' and val.allOfType('string', ts),
             '`val.allOfTypes` arg#1: table of strings expected')
      assert(type(vs)=='table', '`val.allOfTypes` arg#2: table expected')
      if #vs==0 then return false end
      for _, v in ipairs(vs) do if not val.ofTypes(ts, v) then return false end end
      return true
    end,
    -- value checks
    ofValues    = function(evs, v)
      assert(type(evs)=='table', '`val.ofValues` arg#1: table expected')
      for _, ev in ipairs(evs) do if v==ev then return true end end
      return false
    end,
    allOfValue  = function(ev, vs)
      assert(type(vs)=='table', '`val.allOfType` arg#2: table expected')
      if #vs==0 then return false end
      for _, v in ipairs(vs) do if v~=ev then return false end end
      return true
    end,
    allOfValues = function(evs, vs)
      assert(type(evs)=='table', '`val.allOfValues` arg#1: table expected')
      assert(type(vs)=='table', '`val.allOfValues` arg#2: table expected')
      if #vs==0 then return false end
      for _, v in ipairs(vs) do if not val.ofValues(evs, v) then return false end end
      return true
    end,
    -- formatting
    tostring    = function(v)
      if type(v)=='boolean' then return v and 'true' or 'false'
      elseif type(v)=='string' then return "'"..v.."'"
      elseif type(v)=='number' then return v
      end
      return tostring(v)
    end
  }
  func     = {
    parseValKwargs    = function(kwargs)
      -- validate kwargs wrapper
      local kwargsNotTableOrNil = '`func.parseValKwargs` arg#1: nil or table expected'
      assert(kwargs==nil or type(kwargs)=='table', kwargsNotTableOrNil)
      local kwargsIn                         = kwargs or {}
      local kwargsOut                        = {}

      -- validate keyword combinations
      local requiredAndDefaultKwargsCombined = '`func.parseValKwargs` kwargs `required` and `default`: cannot be combined'
      local typeTypesOrChoicesKwargsCombined = '`func.parseValKwargs` kwargs `type`, `types` or `choices`: cannot be combined'
      assert(kwargsIn.required==nil or kwargsIn.default==nil, requiredAndDefaultKwargsCombined)
      assert(kwargsIn.type==nil or kwargsIn.types==nil, typeTypesOrChoicesKwargsCombined)
      assert(kwargsIn.type==nil or kwargsIn.choices==nil, typeTypesOrChoicesKwargsCombined)
      assert(kwargsIn.types==nil or kwargsIn.choices==nil, typeTypesOrChoicesKwargsCombined)

      -- validate required keyword
      local requiredKwargInvalid = '`func.parseValKwargs` kwarg `required`: nil or boolean expected'
      assert(kwargsIn.required==nil or type(kwargsIn.required)=='boolean', requiredKwargInvalid)
      kwargsOut.required          = kwargsIn.default==nil and kwargsIn.required==nil and true or kwargsIn.required

      -- validate type keyword
      local typeKwargInvalid      = '`func.parseValKwargs` kwarg `type`: nil or string expected'
      local defaultKwargNotOfType = '`func.parseValKwargs` kwarg `default`: nil or value of specified type expected'
      assert(kwargsIn.type==nil or type(kwargsIn.type)=='string', typeKwargInvalid)
      if kwargsIn.type~=nil then
        assert(kwargsIn.default==nil or type(kwargsIn.default)==kwargsIn.type, defaultKwargNotOfType)
      end
      kwargsOut.type               = kwargsIn.type

      -- validate types keyword
      local typesKwargInvalid      = '`func.parseValKwargs` kwarg `types`: nil or table[strings] expected'
      local defaultKwargNotOfTypes = '`func.parseValKwargs` kwarg `default`: nil or value of specified types expected'
      assert(kwargsIn.types==nil or (type(kwargsIn.types)=='table' and
          val.allOfType('string', kwargsIn.types)), typesKwargInvalid)
      if kwargsIn.types~=nil then
        assert(kwargsIn.default==nil or val.ofTypes(kwargsIn.types, kwargsIn.default), defaultKwargNotOfTypes)
      end
      kwargsOut.types                = kwargsIn.types

      -- validate choices keyword
      local choicesKwargInvalid      = '`func.parseValKwargs` kwarg `choices`: nil or table[strings, numbers, booleans] expected'
      local defaultKwargNotOfChoices = '`func.parseValKwargs` kwarg `default`: nil or value of specified choices expected'
      assert(kwargsIn.choices==nil or (type(kwargsIn.choices)=='table' and
          val.allOfTypes({'string', 'number', 'boolean'}, kwargsIn.choices)), choicesKwargInvalid)
      if kwargsIn.choices~=nil then
        assert(kwargsIn.default==nil or val.ofValues(kwargsIn.choices, kwargsIn.default), defaultKwargNotOfChoices)
      end
      kwargsOut.choices          = kwargsIn.choices

      -- validate errLevel keyword
      local errLevelKwargInvalid = '`func.parseValKwargs` kwarg `errLevel`: nil or number(>0) expected'
      assert(kwargsIn.errLevel==nil or (type(kwargsIn.errLevel)=='number' and
          kwargsIn.errLevel>0), errLevelKwargInvalid)
      kwargsOut.errLevel = kwargsIn.errLevel or 1

      -- validate default keyword (actually anything is valid)
      kwargsOut.default  = kwargsIn.default

      return kwargsOut
    end,
    parseAssertKwargs = function(kwargs)
      -- validate kwargs wrapper
      local kwargsNotTableOrNil = '`func.parseAssertKwargs` arg#1: nil or table expected'
      assert(kwargs==nil or type(kwargs)=='table', kwargsNotTableOrNil)
      local kwargsIn            = kwargs or {}
      local kwargsOut           = {}

      -- validate message keyword
      local messageKwargInvalid = '`func.parseAssertKwargs` kwarg `message`: nil or string expected'
      assert(kwargsIn.message==nil or type(kwargsIn.message)=='string', messageKwargInvalid)
      kwargsOut.message          = kwargsIn.message

      -- validate errLevel keyword
      local errLevelKwargInvalid = '`func.parseAssertKwargs` kwarg `errLevel`: nil or number(>0) expected'
      assert(kwargsIn.errLevel==nil or (type(kwargsIn.errLevel)=='number' and
          kwargsIn.errLevel>0), errLevelKwargInvalid)
      kwargsOut.errLevel = kwargsIn.errLevel or 1

      return kwargsOut
    end,
    valArg            = function(argument, kwargs)
      local kwargs_ = func.parseValKwargs(kwargs)

      if argument==nil then
        if kwargs_.default~=nil then return kwargs_.default end
        if kwargs_.required then error(err.argMissing(), kwargs_.errLevel) end

      elseif kwargs_.type and type(argument)~=kwargs_.type then
        local errMessage = str.f('Expected a value of type %s, but got %s.',
                                 kwargs_.type, type(argument))
        error(err.type(errMessage), kwargs_.errLevel)

      elseif kwargs_.types and not val.ofTypes(kwargs_.types, argument) then
        local errMessage = str.f('Expected a value of type %s, but got %s.',
                                 table.concat(kwargs_.types, '/'), type(argument))
        error(err.type(errMessage), kwargs_.errLevel)

      elseif kwargs_.choices and not val.ofValues(kwargs_.choices, argument) then
        local choicesStrs = {}
        for _, choice in ipairs(kwargs_.choices) do table.insert(choicesStrs, val.tostring(choice)) end
        local errMessage = str.f('Expected a value of %s, but got %s.',
                                 table.concat(choicesStrs, '/'), val.tostring(argument))
        error(err.value(errMessage), kwargs_.errLevel)
      end

      return argument
    end,
    valKwarg          = function(kwArguments, key, kwargs)
      local kwArgumentsNotTableOrNil = '`func.valKwarg` arg#1: nil or table expected'
      local keyNotString             = '`func.valKwarg` arg#2: string expected'
      assert(kwArguments==nil or type(kwArguments)=='table', kwArgumentsNotTableOrNil)
      assert(type(key)=='string', keyNotString)

      local argument = kwArguments~=nil and kwArguments[key] or nil
      return func.valArg(argument, kwargs)
    end,
    assert            = function(test, kwargs)
      local kwargs_ = func.parseAssertKwargs(kwargs)
      if not test then error(err.assert(kwargs_.message), kwargs_.errLevel) end
    end,
  }
  err      = {
    -- Error message formatters
    base       = function(message, errorType)
      local message_   = func.valArg(message, {type = 'string', default = 'Something went wrong!'})
      local errorType_ = func.valArg(errorType, {type = 'string', default = 'Error'})
      return string.format("\n%s: %s\n", errorType_, message_)
    end,
    type       = function(message)
      local message_ = func.valArg(message, {type = 'string', default = 'Value had unexpected type!'})
      return err.base(message_, 'TypeError')
    end,
    value      = function(message)
      local message_ = func.valArg(message, {type = 'string', default = 'Unexpected value!'})
      return err.base(message_, 'ValueError')
    end,
    argMissing = function(message)
      local message_ = func.valArg(message, {type = 'string', default = 'Argument missing!'})
      return err.base(message_, 'NoArgumentError')
    end,
    assert     = function(message)
      local message_ = func.valArg(message, {type = 'string', default = 'Assertion failed!'})
      return err.base(message_, 'AssertionError')
    end,
    programing = function(message)
      local message_ = func.valArg(message, {type = 'string', default = 'Something was programmed incorrectly!'})
      return err.base(message_, 'ProgrammingError')
    end,
    debug      = function(message)
      local message_ = func.valArg(message, {type = 'string', default = 'Debugger hit!'})
      return err.base(message_, 'Debugger')
    end
  }

  num      = {
    -- Number manipulation and conversion
    fromHex = function(hex)
      -- returns a base-10 integer from a hex value string
      return tonumber(func.valArg(hex, {type = 'string'}), 16)
    end,
    toHex   = function(n)
      -- returns a base-16 string from a number value (zero-padded with 2 characters)
      return str.f("%02x", func.valArg(n, {type = 'number'}))
    end,
    round   = function(n, decimals)
      local n_        = func.valArg(n, {type = 'number'})
      local decimals_ = func.valArg(decimals, {type = 'number', default = 0})
      func.assert(decimals_>=0, {message = '"decimals" must be >= 0'})
      local res = str.f(" %."..decimals_.."f", n_)
      if decimals_>0 then res = res:gsub("%.?0+$", "") end
      return tonumber(res)
    end
  }
  str      = {
    -- String manipulation and extractors
    f     = string.format, -- shorthand
    crop  = function(s, length)
      -- returns a string of limited length
      local s_      = func.valArg(s, {type = 'string'})
      local length_ = func.valArg(length, {type = 'number', default = 0})
      func.assert(length_>=0, {message = '"length" must be >= 0'})
      return s_:sub(1, length_)
    end,
    strip = function(s)
      -- returns a string cleaned from leading and trailing spaces
      local strippedString, _ = func.valArg(s, {type = 'string'}):gsub('%s+', '')
      return strippedString
    end,
    split = function(s, separator)
      -- returns a list of substring of a string
      local s_         = func.valArg(s, {type = 'string'})
      local separator_ = func.valArg(separator, {type = 'string', default = ' '})
      local subStrings = {}
      for subString in string.gmatch(s_, "([^"..separator_.."]+)") do table.insert(subStrings, subString) end
      return subStrings
    end
  }
  tbl      = {
    -- General table functions
    plot        = function(t, indent, _level)
      -- returns a printable string from a table
      local indent_ = func.valArg(indent, {type = 'number', default = 2})
      local level_  = func.valArg(_level, {type = 'number', default = 0})
      func.assert(indent_>0, {message = '"indent" must be >0'})
      func.assert(level_>=0, {message = '"_level" must be >=0. This is for recursive calls only!'})

      local maxLevel = 6
      if type(t)=='table' then
        if level_==maxLevel then
          return str.f('{ <%s> } (max depth reached!)', tostring(t))
        end
        local entries = {}
        for k, v in ipairs(t) do
          table.insert(entries, {str.f('[%s]', k), tbl.plot(v, indent_, level_+1)})
        end
        for k, v in pairs(t) do if type(k)=='string' and k~='metatable' then
          if k=='class' then
            table.insert(entries, {k, v.name})
          else
            table.insert(entries, {k, tbl.plot(v, indent_, level_+1)})
          end
        end end
        local results = {}
        for _, entry in ipairs(entries) do
          local k, v = table.unpack(entry)
          table.insert(results, str.f('%s%s = %s', string.rep(' ', (level_+1)*indent_), k, v))
        end
        if #results==0 then return '{}' end
        return str.f('{\n%s\n%s}',
                     table.concat(results, ',\n'), string.rep(' ', level_*indent_))
      else
        return val.tostring(t)
      end
    end,
    shallowCopy = function(t)
      -- returns a shallow copy
      local copy = {}
      for k, v in pairs(func.valArg(t, {type = 'table'})) do copy[k] = v end
      return copy
    end,
    deepCopy    = function(t)
      -- returns a deep copy
      local copy = {}
      for k, v in pairs(func.valArg(t, {type = 'table'})) do
        copy[k] = type(v)=='table' and tbl.deepCopy(v) or v
      end
      return copy
    end
  }
  dct      = {
    -- Functions for Key/Value-only tables
    -- (in use with tables containing indexes, these may return wrong results)
    len      = function(t)
      -- returns the count of keys
      local t_    = func.valArg(t, {type = 'table'})
      local count = 0
      for k, _ in pairs(t_) do if type(k)=='string' then count = count+1 end end
      return count
    end,
    hasKey   = function(t, key)
      -- returns true if a key exists in a table
      local t_   = func.valArg(t, {type = 'table'})
      local key_ = func.valArg(key, {type = 'string'})
      for k, _ in pairs(t_) do if type(k)=='string' then if k==key_ then return true end end end
      return false
    end,
    hasValue = function(t, value)
      -- returns true if a value exists in a table
      local t_     = func.valArg(t, {type = 'table'})
      local value_ = func.valArg(value, {types = {'number', 'string', 'boolean'}})
      for k, v in pairs(t_) do if type(k)=='string' then if v==value_ then return true end end end
      return false
    end,
    keys     = function(t)
      -- returns a list of all the keys in a table
      local t_   = func.valArg(t, {type = 'table'})
      local keys = {}
      for k, _ in pairs(t_) do if type(k)=='string' then table.insert(keys, k) end end
      return keys
    end,
    equals   = function(t1, t2)
      -- returns true if 2 tables have the same keys and values
      local t1_ = func.valArg(t1, {type = 'table'})
      local t2_ = func.valArg(t2, {type = 'table'})
      if dct.len(t1_)~=dct.len(t2_) then return false end
      -- TODO recursive check
      for k, v in pairs(t1_) do if type(k)=='string' then if t2_[k]~=v then return false end end end
      return true
    end,
    get      = function(t, key, default)
      -- returns the value of a key from a table
      -- (in contrast to Python, this always falls back to nil)
      local t_    = func.valArg(t, {type = 'table'})
      local key_  = func.valArg(key, {type = 'string'})
      local value = t_[key_]
      return value~=nil and value or default
    end,
    pop      = function(t, key, default)
      -- returns the value of a key from a table and removes it from the table
      -- (in contrast to Python, this always falls back to nil)
      local t_    = func.valArg(t, {type = 'table'})
      local key_  = func.valArg(key, {type = 'string'})
      local value = t_[key_]
      t_[key_]    = nil
      return value~=nil and value or default
    end
  }
  lst      = {
    -- Functions for value-only tables
    -- (in use with tables containing keys, these may return wrong results)
    len       = function(t)
      -- returns the count of entries
      local t_ = func.valArg(t, {type = 'table'})
      return #t_
    end,
    hasIndex  = function(t, index)
      -- returns true if an index exists in a table
      local t_     = func.valArg(t, {type = 'table'})
      local index_ = func.valArg(index, {type = 'number'})
      for i, _ in ipairs(t_) do if i==index_ then return true end end
      return false
    end,
    hasValue  = function(t, value)
      -- returns true if a value exists in a table
      local t_     = func.valArg(t, {type = 'table'})
      local value_ = func.valArg(value, {types = {'number', 'string', 'boolean'}})
      for _, v in ipairs(t_) do if v==value_ then return true end end
      return false
    end,
    reversed  = function(t)
      -- returns a reversed table
      local t_       = func.valArg(t, {type = 'table'})
      local reversed = {}
      for i = lst.len(t_), 1, -1 do table.insert(reversed, t_[i]) end
      return reversed
    end,
    last      = function(t)
      -- returns the last value of a table
      local t_ = func.valArg(t, {type = 'table'})
      return t_[#t_]
    end,
    section   = function(t, from, to)
      -- returns a section of a table
      local t_    = func.valArg(t, {type = 'table'})
      local from_ = func.valArg(from, {type = 'number', default = 1})
      local to_   = func.valArg(to, {type = 'number', default = #t})
      func.assert(from_<=to_, {message = '"from"(default: 1) must be <= "to"(default: #t)'})
      local section = {}
      for i = from_, to_ do table.insert(section, t_[i]) end
      return section
    end,
    indexOf   = function(t, value)
      -- returns the index of a value in a table if it exists, otherwise nil
      local t_     = func.valArg(t, {type = 'table'})
      local value_ = func.valArg(value, {types = {'number', 'string', 'boolean'}})
      for i, v in ipairs(t_) do if v==value_ then return i end end
      return nil
    end,
    intersect = function(t1, t2)
      -- returns a list containing all the elements that appear on both tables
      local t1_ = func.valArg(t1, {type = 'table'})
      local t2_ = func.valArg(t2, {type = 'table'})
      if lst.len(t1_)>lst.len(t2_) then t1_, t2_ = t2_, t1_ end
      local intersection = {}
      for _, v in ipairs(t1_) do if lst.hasValue(t2_, v) then table.insert(intersection, v) end end
      return intersection
    end,
    rep       = function(value, n)
      -- returns a new list containing a value n times
      local value_ = func.valArg(value, {types = {'number', 'string', 'boolean', 'table'}})
      local n_     = func.valArg(n, {type = 'number'})
      func.assert(n_>=0, {message = '"n" must be >=0'})
      local list = {}
      for _ = 1, n_ do table.insert(list, type(value_)=='table' and tbl.deepCopy(value_) or value_) end
      return list
    end
  }
  col      = {
    -- Functions for tables of child-tables (eg. { {foo='bar'}, {foo='baz'} })
    -- (the child-tables are expected to have the same scheme)
    -- (in use with tables containing keys, these may return wrong results)
    values  = function(t, key)
      -- returns each value of attr from all child-tables
      -- (!reminder: tables cannot store nil values; so the returned list may not have the same length anymore)
      local t_     = func.valArg(t, {type = 'table'})
      local key_   = func.valArg(key, {type = 'string'})
      local values = {}
      for _, ct in ipairs(t_) do table.insert(values, dct.get(ct, key_)) end
      return values
    end,
    find    = function(t, key, value)
      -- returns the child-table and its index by key and value
      -- (returns nil, nil if not existing)
      local t_     = func.valArg(t, {type = 'table'})
      local key_   = func.valArg(key, {type = 'string'})
      local value_ = func.valArg(value, {types = {'number', 'string', 'boolean'}})
      for i, ct in ipairs(t_) do if ct[key_]==value_ then return ct, i end end
      return nil, nil
    end,
    filter  = function(t, key, value)
      -- returns a list of all child-table matching key and value
      local t_      = func.valArg(t, {type = 'table'})
      local key_    = func.valArg(key, {type = 'string'})
      local value_  = func.valArg(value, {required = false, types = {'number', 'string', 'boolean'}})
      local results = {}
      for _, ct in ipairs(t_) do if ct[key_]==value_ then table.insert(results, ct) end end
      return results
    end,
    exclude = function(t, key, value)
      -- returns a list of all child-table NOT matching key and value
      local t_      = func.valArg(t, {type = 'table'})
      local key_    = func.valArg(key, {type = 'string'})
      local value_  = func.valArg(value, {required = false, types = {'number', 'string', 'boolean'}})
      local results = {}
      for _, ct in ipairs(t_) do if ct[key_]~=value_ then table.insert(results, ct) end end
      return results
    end,
  }

  midi     = {
    ns      = 128, -- (80) Note Off (key abbreviated as 'Note Start')
    ne      = 144, -- (90) Note On (key abbreviated as 'Note End')
    pa      = 160, -- (A0) Polyphonic Aftertouch
    cc      = 176, -- (B0) Control Change
    pc      = 192, -- (C0) Program Change
    ca      = 208, -- (D0) Channel Aftertouch
    pb      = 224, -- (E0) Pitch Bending
    ss      = 240, -- (F0) SysEx Start
    se      = 247, -- (F7) SysEx End
    pattern = function(typeValue, dataByte1, dataByte2, channel)
      local typeValue_ = func.valArg(typeValue, {choices = {
        midi.ns, midi.ne, midi.pa, midi.cc, midi.pc, midi.ca, midi.pb}})
      local dataByte1_ = func.valArg(dataByte1, {types = {'string', 'number'}})
      local dataByte2_ = func.valArg(dataByte2, {types = {'string', 'number'}})
      local channel_   = func.valArg(channel, {type = 'number', default = 0})
      func.assert(channel_>=0 and channel_<=15, {message = 'channel may be a number between 0 and 15'})
      local statusByte_ = num.toHex(typeValue_+channel_)
      dataByte1_        = type(dataByte1_)=='number' and num.toHex(dataByte1_) or dataByte1_
      dataByte2_        = type(dataByte2_)=='number' and num.toHex(dataByte2_) or dataByte2_
      return statusByte_..dataByte1_..dataByte2_
    end
  }

  debugger = function(data)
    -- immediately raises an error with data
    -- the only useful way to debug remote scripts within Reason environment
    local message = data~=nil and str.f("data = %s", tbl.plot(data)) or nil
    error(err.debug(message), 2)
  end
  pprint   = function(data, prepend)
    -- prints using tbl.plot
    -- handy while debugging with interactive Lua
    local prepend_ = func.valArg(prepend, {type = 'string', required = false})
    local plotData = tbl.plot(data)
    if prepend_ then
      print(str.f('%s: %s', prepend_, plotData))
    else
      print(plotData)
    end
  end
end


-- Classes
do
  AutoInput = class('AutoInput')
  do
    function AutoInput:initialize(item, pattern, kwargs)
      local errLevel = 4
      self.item      = func.valArg(item, {type = 'table', errLevel = errLevel})
      self.pattern   = func.valArg(pattern, {type = 'string', errLevel = errLevel})
      self.port      = func.valKwarg(kwargs, 'port', {type = 'number', required = false, errLevel = errLevel})
      self.value     = func.valKwarg(kwargs, 'value', {type = 'string', required = false, errLevel = errLevel})
      self.note      = func.valKwarg(kwargs, 'note', {type = 'string', required = false, errLevel = errLevel})
      self.velocity  = func.valKwarg(kwargs, 'velocity', {type = 'string', required = false, errLevel = errLevel})
    end
    function AutoInput:toInternal()
      return {name  = self.item.name, pattern = self.pattern, port = self.port,
              value = self.value, note = self.note, velocity = self.velocity}
    end
  end

  AutoOutput = class('AutoOutput')
  do
    function AutoOutput:initialize(item, pattern, kwargs)
      local errLevel = 4
      self.item      = func.valArg(item, {type = 'table', errLevel = errLevel})
      self.pattern   = func.valArg(pattern, {type = 'string', errLevel = errLevel})
      self.port      = func.valKwarg(kwargs, 'port', {type = 'number', required = false, errLevel = errLevel})
      self.x         = func.valKwarg(kwargs, 'x', {type = 'string', required = false, errLevel = errLevel})
      self.y         = func.valKwarg(kwargs, 'y', {type = 'string', required = false, errLevel = errLevel})
      self.z         = func.valKwarg(kwargs, 'z', {type = 'string', required = false, errLevel = errLevel})
    end
    function AutoOutput:toInternal()
      return {name = self.item.name, pattern = self.pattern, port = self.port,
              x    = self.x, y = self.y, z = self.z}
    end
  end

  ControlItem = class('ControlItem')
  do
    function ControlItem:initialize(surface, name, kwargs)
      local errLevel = 5

      -- setup static modesData
      if self.class.modesData==nil and self.class.setupModesData then self.class.setupModesData() end

      -- link item <-> surface
      self.surface = func.valArg(surface, {type = 'table', errLevel = errLevel})
      table.insert(self.surface.items, self)
      self.index  = #self.surface.items

      -- item data
      self.name   = func.valArg(name, {type = 'string', errLevel = errLevel})
      self.input  = func.valKwarg(kwargs, 'input', {
        default = 'noinput', choices = {'noinput', 'button', 'value', 'delta', 'keyboard'}, errLevel = errLevel})
      self.output = func.valKwarg(kwargs, 'output', {
        default = 'nooutput', choices = {'nooutput', 'value', 'text'}, errLevel = errLevel})
      self.min    = func.valKwarg(kwargs, 'min', {type = 'number', required = false, errLevel = errLevel})
      self.max    = func.valKwarg(kwargs, 'max', {type = 'number', required = false, errLevel = errLevel})
    end
    function ControlItem:toInternal()
      local modes = func.valArg(self.class.modesData, {type = 'table', default = {}})
      return {name = self.name, input = self.input, output = self.output,
              min  = self.min, max = self.max, modes = col.values(modes, 'name')}
    end
    function ControlItem:__tostring()
      return str.f('%s("%s")', self.class.name, self.name)
    end
    -- utility wrapper methods
    --function ControlItem:modeData()
    --  return #self.modes and self.modes[remote.get_item_mode(self.index)] or nil
    --end
    function ControlItem:isEnabled()
      return remote.is_item_enabled(self.index)
    end
    function ControlItem:remotableName()
      return remote.get_item_name(self.index)
    end
    function ControlItem:remotableNameAndValue()
      return remote.get_item_name_and_value(self.index)
    end
    function ControlItem:remotableShortName()
      return remote.get_item_short_name(self.index)
    end
    function ControlItem:remotableShortNameAndValue()
      return remote.get_item_short_name_and_value(self.index)
    end
    function ControlItem:remotableShortestName()
      return remote.get_item_shortest_name(self.index)
    end
    function ControlItem:remotableShortestNameAndValue()
      return remote.get_item_shortest_name_and_value(self.index)
    end
    function ControlItem:remotableState()
      return remote.get_item_state(self.index)
    end
    function ControlItem:remotableTextValue()
      return remote.get_item_text_value(self.index)
    end
    function ControlItem:remotableValue()
      return remote.get_item_value(self.index)
    end
  end

  ScriptItem = class('ScriptItem', ControlItem)
  do
    function ScriptItem:initialize(surface, name)
      ControlItem.initialize(self, surface, name, {output = 'text'})
      self.surface.scriptState[self.name] = ''
      table.insert(self.surface.scriptItemIndices, self.index)
    end
    function ScriptItem:setState()
      self.surface.scriptState[self.name] = self:isEnabled() and self:remotableTextValue() or ''
    end
  end

  VirtualItem = class('VirtualItem', ControlItem)
  do

  end

  ControlSurface = class('ControlSurface')
  do
    function ControlSurface:initialize(manufacturer, model)
      self.manufacturer      = manufacturer
      self.model             = model
      self.items             = {}
      self.midiQueue         = {}
      self.scriptState       = {}
      self.scriptItemIndices = {}
      if self.setup then self:setup() end
    end
    function ControlSurface:getRemoteItems()
      local internalItems = {}
      for _, item in ipairs(self.items) do table.insert(internalItems, item:toInternal()) end
      return internalItems
    end
    function ControlSurface:getRemoteAutoInputs()
      local internalAutoInputs = {}
      for _, item in ipairs(col.exclude(self.items, 'autoInput', nil)) do
        table.insert(internalAutoInputs, item.autoInput:toInternal())
      end
      return internalAutoInputs
    end
    function ControlSurface:getRemoteAutoOutputs()
      local internalAutoOutputs = {}
      for _, item in ipairs(col.exclude(self.items, 'autoOutput', nil)) do
        table.insert(internalAutoOutputs, item.autoOutput:toInternal())
      end
      return internalAutoOutputs
    end
    function ControlSurface:setScriptState(changedItems)
      for _, index in ipairs(lst.intersect(changedItems, self.scriptItemIndices)) do
        self.items[index]:setState()
      end
    end
  end
end

-- Remote Callbacks
do
  SURFACE   = nil
  callbacks = {
    init      = function(manufacturer, model)
      SURFACE = initSurface~=nil and initSurface(manufacturer, model) or nil
      func.assert(ControlSurface.isInstanceOf(SURFACE, ControlSurface),
                  {message = 'global function `initSurface` must return a `ControlSurface` instance!'})

      remote.define_items(SURFACE:getRemoteItems())
      remote.define_auto_inputs(SURFACE:getRemoteAutoInputs())
      remote.define_auto_outputs(SURFACE:getRemoteAutoOutputs())
    end,
    set_state = function(changedItems)
      SURFACE:setScriptState(changedItems)
    end
  }
end

-- Remote Debug
do
  remoteDebug = {
    isDebugEnvironment  = true,
    define_items        = function(items)
      pprint(col.values(func.valArg(items, {type = 'table'}), 'name'), 'Defined Items')
    end,
    define_auto_inputs  = function(inputs)
      pprint(col.values(func.valArg(inputs, {type = 'table'}), 'name'), 'Defined Auto Inputs')
    end,
    define_auto_outputs = function(outputs)
      pprint(col.values(func.valArg(outputs, {type = 'table'}), 'name'), 'Defined Auto Outputs')
    end,
    is_item_enabled     = function(item_index)
      return true
    end,
    get_item_text_value = function(item_index)
      return 'item text value'
    end
  }
  remote      = remote or remoteDebug
end
